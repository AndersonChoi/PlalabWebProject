#Web study

## Week 2. Web Architectures

### 1. MVVM

- Model-View-**ViewModel**
- Use cases : Knockout.js
- John Gossman, Microsoft, 2005 : WPF, Silverlight
- MVC에서 컨트롤러가 뷰모델로 교체된 형태
- 뷰모델은 뷰(UI Layer) 아래에 위치함
- 뷰모델은 뷰가 필요로 하는 **데이터**와 **커맨드 객체**를 노출해 주기 때문에 뷰가 필요로하는 **데이터**와 **액션**을 담고 있는 컨테이너 객체로 볼 수도 있음 => 커맨드 객체? 액션?

#### MVVM의 차별성 (vs MVC)

- MVVM의 뷰모델은 뷰가 필요로하는 **데이터**와 **커맨드**를 제공하기 위해서 만들어졌음
- 뷰모델은 이름그대로 **뷰를 위한 모델**이며 뷰모델을 뷰에 바인딩할 때 가장 강력합
- 뷰모델은 여러가지 뷰를 제공하는 일반적인 객체가 아니라, 각 뷰에 맞춰서 만들어진 것임. 따라서 뷰는 뷰모델에 대해서만 알고 있으면 되고 그 외의 아키텍처에 대해서는 신경쓰지 않아도 됨


- 사용자 입력은 뷰에서 받음
- 뷰는 뷰모델의 레퍼런스를 가짐. 따라서 하나의 뷰모델에서 여러 뷰를 지원할 수 있음
- 뷰와 모델은 서로에 대해 알지 못함. 뷰모델이 모델로부터 데이터를 가져와서 뷰에게 제공함.
- 장점 (vs MVP) : **커맨드**와 **데이터바인딩**으로 뷰와 뷰모델 간의 의존성 제거


### 2. MVC

- Model-View-**Controller**


- 사용자 입력은 컨트롤러에서 받음
- 하나의 컨트롤러는 명령(operation)에 따라 여러 뷰를 렌더링 할 수 있음
- 뷰는 컨트롤러에 대해 알지 못함
- 컨트롤러는 모델과 상호작용하고, 모델을 뷰로 넘김. 따라서 모델과 뷰는 서로를 인지함
- 단점 (vs MVP, MVVM) : 뷰는 모델을 이용하기 때문에 서로간의 의존성을 완벽히 피할 수 없음

#### 뷰가 업데이트되는 방식
컨트롤러는 뷰를 선택만하고 업데이트를 시켜주지 않기 때문에, 뷰는 모델을 이용하여 업데이트 하게 됨
1. 모델이 뷰에게 Notify 해주는 방법
2. 뷰에서 Polling을 통해 모델의 변화를 알아채는 방법
3. 기타 등등


### 3. MVP

- Model-View-**Presenter**
- MVC에서 컨트롤러가 프레젠터로 교체된 형태
- 뷰와 프레젠터는 같은 레벨에 있음
- 프레젠터는 뷰와 모델의 이벤트를 모두 받으면서 둘 사이의 상호작용을 조정함


- 사용자 입력은 프레젠터에서 받음
- 각 뷰와 프레젠터는 1:1 대응 관계이며, 서로의 레퍼런스를 가짐
- 뷰와 모델은 서로에 대해 알지 못함. 프레젠터는 모델의 레퍼런스를 갖기 때문에 뷰와 모델 사이에서 다리와 같은 역할을 함
- 장점 (vs MVC) : 뷰와 모델의 완전한 분리
- 단점 (vs MVC, MVVM) : 뷰와 프레젠터가 1:1 대응 관계로써 의존성이 매우 강함


### 참고

1. WPF란? : (Microsoft) Windows Presentation Foundation. 이를 이용해 시각적으로 뛰어난 사용자 환경의 Windows용 데스크톱 클라이언트 응용 프로그램을 만들 수 있음


### References

- https://blog.outsider.ne.kr/672
- https://tomyrhymond.wordpress.com/2011/09/16/mvc-mvp-and-mvvm/